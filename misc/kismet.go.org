package kismet

import (
	"bufio"
	"database/sql"
	"fmt"
	"log"
	"net"
	"regexp"
	"strconv"
	"strings"
	"time"
)

/*
!6 CAPABILITY TERMINATE - *CAPABILITY: TERMINATE text
	*TERMINATE: Kismet server terminating.
!8 CAPABILITY PACKET - *CAPABILITY: PACKET type,subtype,timesec,encrypted,weak,beaconrate,sourcemac,destmac,bssid,ssid,prototype,sourceip,destip,sourceport,destport,nbtype,nbsource,sourcename
!10 CAPABILITY PLUGIN - *CAPABILITY: PLUGIN filename,name,version,description,unloadable,root
!11 CAPABILITY SOURCE - *CAPABILITY: SOURCE interface,type,username,channel,uuid,packets,hop,velocity,dwell,hop_time_sec,hop_time_usec,channellist,error,warning
	*SOURCE: wlan1 rt2800usb ncard 9 6454df0a-6620-11e4-974a-0205a623e301 4 3 3 0 0 0 1,5,9,13,40,149,5795,2,6,10,14,44,5755,161,3,7,11,36,46,153,165,4,8,12,38,48,157 0 \001\001
!12 CAPABILITY ALERT - *CAPABILITY: ALERT sec,usec,header,bssid,source,dest,other,channel,text
	*ALERT: 1415361544 961980 BCASTDISCON 00:C0:CA:32:B3:DE 00:C0:CA:32:B3:DE FF:FF:FF:FF:FF:FF 00:00:00:00:00:00 0 \001Network BSSID 00:C0:CA:32:B3:DE broadcast deauthenticate/disassociation of all clients, possible DoS\001
!13 CAPABILITY COMMON - *CAPABILITY: COMMON phytype,macaddr,firsttime,lasttime,packets,llcpackets,errorpackets,datapackets,cryptpackets,datasize,newpackets,channel,frequency,freqmhz,gpsfixed,minlat,minlon,minalt,minspd,maxlat,maxlon,maxalt,maxspd,signaldbm,noisedbm,minsignaldbm,minnoisedbm,signalrssi,noiserssi,minsignalrssi,minnoiserssi,maxsignalrssi,maxnoiserssi,bestlat,bestlon,bestalt,agglat,agglon,aggalt,aggpoints
!14 CAPABILITY TRACKINFO - *CAPABILITY: TRACKINFO devices,packets,datapackets,cryptpackets,errorpackets,filterpackets,packetrate
!15 CAPABILITY WEPKEY - *CAPABILITY: WEPKEY origin,bssid,key,encrypted,failed
!16 CAPABILITY STRING - *CAPABILITY: STRING bssid,source,dest,string
!17 CAPABILITY GPS - *CAPABILITY: GPS lat,lon,alt,spd,heading,fix,satinfo,hdop,vdop,connected
!18 CAPABILITY BSSID - *CAPABILITY: BSSID bssid,type,llcpackets,datapackets,cryptpackets,manuf,channel,firsttime,lasttime,atype,rangeip,netmaskip,gatewayip,gpsfixed,minlat,minlon,minalt,minspd,maxlat,maxlon,maxalt,maxspd,signal_dbm,noise_dbm,minsignal_dbm,minnoise_dbm,maxsignal_dbm,maxnoise_dbm,signal_rssi,noise_rssi,minsignal_rssi,minnoise_rssi,maxsignal_rssi,maxnoise_rssi,bestlat,bestlon,bestalt,agglat,agglon,aggalt,aggpoints,datasize,turbocellnid,turbocellmode,turbocellsat,carrierset,maxseenrate,encodingset,decrypted,dupeivpackets,bsstimestamp,cdpdevice,cdpport,fragments,retries,newpackets,freqmhz,datacryptset
	*BSSID: 4C:60:DE:25:93:E4 0 1 0 0 Netgear 1 1415325005 1415325005 0 0.0.0.0 0.0.0.0 0.0.0.0 0 90 180 100000 100000 -90 -180 -100000 -100000 -47 0 -47 0 -47 -256 0 0 1024 1024 0 0 0 0 0 0 0 0 0 0 0 0 0 1 10 1 0 0 287300506009     0 0 1 2412:1* 0
!19 CAPABILITY SSID - *CAPABILITY: SSID mac,checksum,type,ssid,beaconinfo,cryptset,cloaked,firsttime,lasttime,maxrate,beaconrate,packets,beacons,dot11d
	*SSID: 4C:60:DE:25:93:E4 684590368 0 \0012turntablesG\001 \001 \001 706 0 1415325005 1415325005 54 10 1 1 \001XXX:\001
!20 CAPABILITY CLIENT - *CAPABILITY: CLIENT bssid,mac,type,firsttime,lasttime,manuf,llcpackets,datapackets,cryptpackets,gpsfixed,minlat,minlon,minalt,minspd,maxlat,maxlon,maxalt,maxspd,agglat,agglon,aggalt,aggpoints,signal_dbm,noise_dbm,minsignal_dbm,minnoise_dbm,maxsignal_dbm,maxnoise_dbm,signal_rssi,noise_rssi,minsignal_rssi,minnoise_rssi,maxsignal_rssi,maxnoise_rssi,bestlat,bestlon,bestalt,atype,ip,gatewayip,datasize,maxseenrate,encodingset,carrierset,decrypted,channel,fragments,retries,newpackets,freqmhz,cdpdevice,cdpport,dot11d,dhcphost,dhcpvendor,datacryptset
	*CLIENT: 4C:60:DE:25:93:E4 4C:60:DE:25:93:E4 1 1415325005 1415325005 Netgear 4 0 0 0 90 180 100000 -90 -180 -100000 0 0 0 0 -46 0 -48 0 -46 -256 0 0 1024 1024 0 0 0 0 0 0 0.0.0.0 0.0.0.0 0 10 1 1 0 1 0 0 4 2412:4*       0
!21 CAPABILITY BSSIDSRC - *CAPABILITY: BSSIDSRC bssid,uuid,lasttime,numpackets,signal_dbm,noise_dbm,minsignal_dbm,minnoise_dbm,maxsignal_dbm,maxnoise_dbm,signal_rssi,noise_rssi,minsignal_rssi,minnoise_rssi,maxsignal_rssi,maxnoise_rssi
	*BSSIDSRC: 4C:60:DE:25:93:E4 6454df0a-6620-11e4-974a-0205a623e301 1415325005 4
!22 CAPABILITY CLISRC - *CAPABILITY: CLISRC bssid,mac,uuid,lasttime,numpackets,signal_dbm,noise_dbm,minsignal_dbm,minnoise_dbm,maxsignal_dbm,maxnoise_dbm,signal_rssi,noise_rssi,minsignal_rssi,minnoise_rssi,maxsignal_rssi,maxnoise_rssi
	*CLISRC: 4C:60:DE:25:93:E4 4C:60:DE:25:93:E4 6454df0a-6620-11e4-974a-0205a623e301 1415325005 4
!23 CAPABILITY NETTAG - *CAPABILITY: NETTAG bssid,tag,value
!24 CAPABILITY CLITAG - *CAPABILITY: CLITAG bssid,mac,tag,value
!25 CAPABILITY REMOVE - *CAPABILITY: REMOVE bssid
!26 CAPABILITY CHANNEL - *CAPABILITY: CHANNEL channel,time_on,packets,packetsdelta,usecused,bytes,bytesdelta,networks,maxsignal_dbm,maxsignal_rssi,maxnoise_dbm,maxnoise_rssi,activenetworks
	*CHANNEL: 34048 0 1 0 0 94 0 1 1 0 -256 0 0
!27 CAPABILITY INFO - *CAPABILITY: INFO networks,packets,crypt,noise,dropped,rate,filtered,clients,llcpackets,datapackets,numsources,numerrorsources
	*INFO: 6 2588 26 376 376 0 0 0 2140 72 1 0
!28 CAPABILITY BATTERY - *CAPABILITY: BATTERY percentage,charging,ac,remaining
	*BATTERY: 0 0 1 0
!29 CAPABILITY CRITFAIL - *CAPABILITY: CRITFAIL id,time,message
*/

type kismetServer struct {
	version   string
	starttime string
	name      string
	dumpfiles []string
	uid       int
}

type networkInterface struct {
	iface       string
	uuid        string
	lname       string
	channel     string
	hop         string
	velocity    string
	channellist string
	/*
		channel     int
		hop         bool
		velocity    int
		channellist string
	*/
}

type kismetClient struct {
	host       string
	port       int
	db         *sql.DB
	debug      bool
	conn       net.Conn
	server     kismetServer
	index      int
	pipeline   map[int]string
	interfaces map[string]networkInterface
}

type accessPoint struct {
	uuid string
	//type?? - instrastructure vs ad-hoc maybe... all i've seen so far are zeros
	manuf     string
	channel   int
	firsttime string
	lasttime  string
	//atype
	//rangeip
	//netmaskip
	//gatewayip
	signalDBM    int
	minSignalDBM int
	maxSignalDBM int
	numPackets   int
}

type network struct {
	ssid string
	//type???
	cloaked      bool
	firsttime    int
	lasttime     int
	maxrate      int
	encryption   string
	accessPoints map[string]accessPoint
}

var (
	client     kismetClient
	networks   map[string]network
	tstamp     string
	packets    int
	packetRate int
	reNULL     *regexp.Regexp
)

func Send(cmd string, params string) {
	cmdstr := cmd + " " + params
	client.pipeline[client.index] = cmdstr
	cmdstr = fmt.Sprintf("!%d ", client.index) + cmdstr
	if client.debug {
		fmt.Println("SEND: " + cmdstr)
	}
	client.conn.Write([]byte(cmdstr + "\n"))
	client.index += 1
}

func Run(h string, p int, s *sql.DB, d bool) {
	// Set package variables
	client.host = h
	client.port = p
	client.db = s
	client.debug = d
	client.index = 1
	client.pipeline = map[int]string{}
	client.interfaces = map[string]networkInterface{}

	// Establish connection to kismet server
	var err error
	client.conn, err = net.Dial("tcp", fmt.Sprintf("%s:%d", client.host, client.port))
	if err != nil {
		log.Fatal("Can't connect to kismet server")
	}

	// Listen for responses
	go listen()

	// Setup the client
	setupClient()

	// Get configured interfaces
	/*
		for i := 0; i < 5; i++ {
			time.Sleep(1 * time.Second)
		}
	*/
}

func listen() {
	// Create mapping to parse kismet responses
	responses := map[string]interface{}{
		"KISMET":     parseKISMET,
		"PROTOCOLS":  parsePROTOCOLS,
		"CAPABILITY": parseCAPABILITY,
		"TIME":       parseTIME,
		"ACK":        parseACK,
		"INFO":       parseINFO,
		"STATUS":     parseSTATUS,
		"ALERT":      parseALERT,
		"ERROR":      parseERROR,
		"BSSID":      parseBSSID,
		"SSID":       parseSSID,
		"BSSIDSRC":   parseBSSIDSRC,
		"CLIENT":     parseCLIENT,
		"CLISRC":     parseCLISRC,
		"SOURCE":     parseSOURCE,
		"TERMINATE":  parseTERMINATE,
	}

	// Continuously read data
	scanner := bufio.NewScanner(client.conn)
	reNULL = regexp.MustCompile(`\001`)
	re := regexp.MustCompile(`\*([^:]+): (.*)`)
	for scanner.Scan() {
		status := scanner.Text()

		// Determine response type
		status = strings.TrimSpace(status)
		matches := re.FindStringSubmatch(status)
		if len(matches) == 3 {
			f, found := responses[matches[1]]
			if found {
				f.(func(string))(matches[2])
			} else if client.debug {
				fmt.Println(status)
				fmt.Println("UNKNOWN CMD: " + matches[1])
			}
		} else if client.debug {
			fmt.Println("UNKNOWN RESPONSE: " + status)
		}
	}
	fmt.Println("QUITING")
}

func setupClient() {
	// Disable TIME
	Send("REMOVE", "TIME")

	// Enable default capabilities
	capabilities := []string{
		"INFO networks,packets,rate,filtered,llcpackets,numsources,numerrorsources,",
		"STATUS text,flags,",
		"SOURCE interface,type,username,channel,uuid,packets,hop,velocity,dwell,hop_time_sec,hop_time_usec,channellist,error,warning,",
		"ALERT sec,usec,header,bssid,source,dest,other,channel,text,",
		"ERROR cmdid,text,",
		"BSSID bssid,type,llcpackets,datapackets,cryptpackets,manuf,channel,firsttime,lasttime,atype,rangeip,netmaskip,gatewayip,gpsfixed,minlat,minlon,minalt,minspd,maxlat,maxlon,maxalt,maxspd,signal_dbm,noise_dbm,minsignal_dbm,minnoise_dbm,maxsignal_dbm,maxnoise_dbm,signal_rssi,noise_rssi,minsignal_rssi,minnoise_rssi,maxsignal_rssi,maxnoise_rssi,bestlat,bestlon,bestalt,agglat,agglon,aggalt,aggpoints,datasize,turbocellnid,turbocellmode,turbocellsat,carrierset,maxseenrate,encodingset,decrypted,dupeivpackets,bsstimestamp,cdpdevice,cdpport,fragments,retries,newpackets,freqmhz,datacryptset,",
		/*
			"BSSIDSRC bssid,uuid,lasttime,numpackets,",
			"CLISRC bssid,mac,uuid,lasttime,numpackets,",
			"SSID mac,checksum,type,ssid,beaconinfo,cryptset,cloaked,firsttime,lasttime,maxrate,beaconrate,packets,beacons,dot11d,",
			"NETTAG bssid,tag,value,",
			"CLITAG bssid,mac,tag,value,",
			"CLIENT bssid,mac,type,firsttime,lasttime,manuf,llcpackets,datapackets,cryptpackets,gpsfixed,minlat,minlon,minalt,maxlat,maxlon,maxalt,agglat,agglon,aggalt,aggpoints,signal_dbm,noise_dbm,minsignal_dbm,minnoise_dbm,maxsignal_dbm,maxnoise_dbm,signal_rssi,noise_rssi,minsignal_rssi,minnoise_rssi,maxsignal_rssi,maxnoise_rssi,bestlat,bestlon,bestalt,atype,ip,gatewayip,datasize,maxseenrate,encodingset,carrierset,decrypted,channel,fragments,retries,newpackets,freqmhz,cdpdevice,cdpport,dhcphost,dhcpvendor,datacryptset,",
		*/
	}

	for _, txt := range capabilities {
		Send("ENABLE", txt)
	}

	_, ok := client.pipeline[client.index]
	for ok || len(client.pipeline) > 0 {
		time.Sleep(1 * time.Second)
		_, ok = client.pipeline[client.index]
	}
}

func parseFields(txt string) []string {
	//	params := strings.Split(strings.TrimSpace(txt), " ")

	//	for i := 0; i < len(params); i++ {
	//		params[i] = reNULL.ReplaceAllString(params[i], "")
	//	}

	re := regexp.MustCompile(`([^ \001]+|\001[^\001]*\001)`)
	matches := re.FindAllStringSubmatch(txt, 58)
	var params []string
	for i := 0; i < len(matches); i++ {
		txt = matches[i][0]
		txt = reNULL.ReplaceAllString(txt, "")
		txt = strings.TrimSpace(txt)
		params = append(params, txt)
	}
	//fmt.Println(strings.Join(params, ","))
	return params
}

func parseKISMET(txt string) {
	if client.debug {
		fmt.Println("KISMET: " + txt)
	}

	fields := parseFields(txt)

	client.server.version = fields[0]
	client.server.starttime = fields[1]
	client.server.name = fields[2]
	client.server.dumpfiles = strings.Split(fields[3], ",")
	client.server.uid, _ = strconv.Atoi(fields[4])
}

func parsePROTOCOLS(txt string) {
	if client.debug {
		fmt.Println("PROTOCOLS: " + txt)
	}
}

func parseCAPABILITY(txt string) {
	if client.debug {
		fmt.Println("CAPABILITY: " + txt)
	}
}

func parseTIME(txt string) {
	if client.debug {
		fmt.Println("TIME: " + txt)
	}
	tstamp = txt
}

func parseACK(txt string) {
	if client.debug {
		fmt.Println("ACK: " + txt)
	}

	fields := parseFields(txt)

	i, _ := strconv.Atoi(fields[0])
	delete(client.pipeline, i)
	if client.debug {
		fmt.Println("ACK: " + fields[0])
		fmt.Println("PIPELINE:", client.pipeline)
	}
}

func parseINFO(txt string) {
	if client.debug {
		fmt.Println("INFO: " + txt)
	}

	fields := parseFields(txt)
	fmt.Println(fields)

	packets, _ = strconv.Atoi(fields[1])
	packetRate, _ = strconv.Atoi(fields[2])
}

func parseSTATUS(txt string) {
	/*
		STATUS-INFO: Created source wlan2 with UUID 28fe93cc-67c6-11e4-bb2e-0205a623e401
		STATUS-INFO: Added source 'wlan2:name=ncard' from client ADDSOURCE
		STATUS-INFO: Source 'wlan2' attempting to create mac80211 VAP 'wlan2mon'
		STATUS-INFO: Started source 'ncard'
		STATUS-ERROR: Reading packet from pcap interface wlan2mon failed, interface is no longer available.
	*/
	if client.debug {
		fmt.Println("STATUS: " + txt)
	}

	//re := regexp.MustCompile(`^\001(.*)\001 (\d+)$`)
	//matches := re.FindStringSubmatch(txt)
	fields := parseFields(txt)
	if len(fields) == 2 {
		switch {
		case fields[1] == "2":
			fmt.Println("STATUS-INFO: " + fields[0])
		case fields[1] == "4":
			fmt.Println("STATUS-ERROR: " + fields[0])
		default:
			if client.debug {
				fmt.Println("STATUS-OTHER: (" + fields[1] + ") " + fields[0])
			}
		}
	}
}

func parseSOURCE(txt string) {
	if client.debug {
		fmt.Println("SOURCE: " + txt)
	}

	fields := parseFields(txt)

	_, exists := client.interfaces[fields[0]]
	if !exists {
		client.interfaces[fields[0]] = networkInterface{fields[0], fields[4], fields[2], fields[3], fields[6], fields[7], fields[11]}
	} else {
		nic := client.interfaces[fields[0]]
		nic.channel = fields[3]
		nic.hop = fields[6]
		nic.velocity = fields[7]
		nic.channellist = fields[11]
		client.interfaces[fields[0]] = nic
	}
	if fields[13] != "" {
		fmt.Println("NIC-WARNING: (" + fields[0] + ") " + fields[13])
	}
}

func parseALERT(txt string) {
	if client.debug {
		fmt.Println("ALERT: " + txt)
	}

	fields := parseFields(txt)
	fmt.Println("ALERT: " + fields[2] + " " + fields[8])
}

func parseERROR(txt string) {
	if client.debug {
		fmt.Println("ERROR: " + txt)
	}

	fields := parseFields(txt)
	if len(fields) == 2 {
		i, _ := strconv.Atoi(fields[0])
		delete(client.pipeline, i)
		if client.debug {
			fmt.Println("ERROR: " + fields[1])
			fmt.Println("PIPELINE:", client.pipeline)
		}
	}
}

func parseBSSID(txt string) {
	//"BSSID bssid,type,llcpackets,datapackets,cryptpackets,manuf,channel,firsttime,lasttime,atype,rangeip,netmaskip,gatewayip,gpsfixed,minlat,minlon,minalt,minspd,maxlat,maxlon,maxalt,maxspd,signal_dbm,noise_dbm,minsignal_dbm,minnoise_dbm,maxsignal_dbm,maxnoise_dbm,signal_rssi,noise_rssi,minsignal_rssi,minnoise_rssi,maxsignal_rssi,maxnoise_rssi,bestlat,bestlon,bestalt,agglat,agglon,aggalt,aggpoints,datasize,turbocellnid,turbocellmode,turbocellsat,carrierset,maxseenrate,encodingset,decrypted,dupeivpackets,bsstimestamp,cdpdevice,cdpport,fragments,retries,newpackets,freqmhz,datacryptset,",
	//00:22:55:43:34:41,0,87,24,0,Cisco,11,1415940771,1415942632,5,0.0.0.0,192.0.0.0,0.0.0.0,0,90,180,100000,100000,-90,-180,-100000,-100000,-85,0,-87,0,-75,-256,0,0,1024,1024,0,0,0,0,0,0,0,0,0,1825,0,0,0,5,240,3,0,0,5488537600239,,,,,0,0,2,2462:111*,0
	if client.debug {
		fmt.Println("BSSID: " + txt)
	}

	fields := parseFields(txt)
	fmt.Println(strings.Join(fields, ","))
}

func parseSSID(txt string) {
	if client.debug {
		fmt.Println("SSID: " + txt)
	}
}

func parseBSSIDSRC(txt string) {
	if client.debug {
		fmt.Println("BSSIDSRC: " + txt)
	}
}

func parseCLIENT(txt string) {
	if client.debug {
		fmt.Println("CLIENT: " + txt)
	}
}

func parseCLISRC(txt string) {
	if client.debug {
		fmt.Println("CLISRC: " + txt)
	}
}

func parseTERMINATE(txt string) {
	if client.debug {
		fmt.Println("TERMINATE: " + txt)
	}
}

/*
func (kismet *KismetClient) test1() {
	fmt.Println("test1")
	fmt.Fprintf(kismet.conn, "!1 ENABLE source interface\n")
}

func (kismet *KismetClient) test2() {
	fmt.Println("test2")
	fmt.Fprintf(kismet.conn, "!2 REMOVE source\n")
}

func test3() {
	fmt.Println("test3")
}
*/
